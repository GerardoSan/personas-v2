name: CI/CD

on:
  push:
    branches: [ "main" ]
  pull_request:

env:
  AWS_REGION: us-east-2
  TERRAFORM_DIR: infra/terraform
  TERRAFORM_VERSION: 1.9.2
  ECR_REPOSITORY: personas-frontend
  ECS_SERVICE: personas-frontend
  ECS_CLUSTER: personas-cluster
  ECS_TASK_DEFINITION: frontend/ecs-task-definition.json
  CONTAINER_NAME: personas-frontend

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Terraform
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip curl
          curl -fsSL https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip -o terraform.zip
          unzip terraform.zip
          sudo mv terraform /usr/local/bin/
          terraform -version

      # Construir y desplegar el frontend
      - name: Install Node.js and dependencies
        run: |
          # Make the setup script executable
          chmod +x frontend/setup-node.sh
          # Run the setup script
          ./frontend/setup-node.sh

      - name: Build frontend
        working-directory: frontend
        run: |
          npm run build
          echo "REACT_APP_API_URL=${{ secrets.API_GATEWAY_URL }}" > .env.production

      - name: Ensure ECR repository exists
        run: |
          # Verificar si el repositorio existe, si no existe, crearlo
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} || \
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }}

      - name: Configure AWS CLI for ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Build and push Docker image
        working-directory: frontend
        run: |
          docker build -t ${{ env.ECR_REPOSITORY }}:${{ github.sha }} .
          docker tag ${{ env.ECR_REPOSITORY }}:${{ github.sha }} ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
          echo "image=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Build Lambda artifact
        working-directory: lambda
        run: |
          chmod +x build.sh
          ./build.sh
          aws s3 cp personas_lambda.zip s3://${{ secrets.ARTIFACTS_BUCKET }}/${{ secrets.LAMBDA_S3_KEY }}

      - name: Terraform Init
        run: terraform -chdir=${{ env.TERRAFORM_DIR }} init

      - name: Terraform Plan
        run: |
          terraform -chdir=${{ env.TERRAFORM_DIR }} plan \
          -var="artifacts_bucket=${{ secrets.ARTIFACTS_BUCKET }}" \
          -var="lambda_s3_key=${{ secrets.LAMBDA_S3_KEY }}" \
          -out=tfplan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        run: terraform -chdir=${{ env.TERRAFORM_DIR }} apply -auto-approve tfplan

      - name: Desplegar en ECS
        if: github.ref == 'refs/heads/main'
        working-directory: frontend
        run: |
          # Obtener el ID de la API Gateway
          API_ID=$(aws apigatewayv2 get-apis --query "Items[?Name=='personas-api'].ApiId" --output text)
          if [ -z "$API_ID" ]; then
            echo "Error: No se pudo obtener el ID de la API Gateway"
            exit 1
          fi
          
          # Obtener el nombre del stage (por defecto es $default para HTTP APIs)
          STAGE="$DEFAULT"
          API_GATEWAY_URL="https://${API_ID}.execute-api.${AWS_REGION}.amazonaws.com/"
          echo "URL de API Gateway: $API_GATEWAY_URL"
          
          # Obtener el ARN del rol de ejecución de ECS
          TASK_EXECUTION_ROLE_ARN=$(aws iam get-role --role-name ecsTaskExecutionRole --query 'Role.Arn' --output text)
          if [ -z "$TASK_EXECUTION_ROLE_ARN" ]; then
            echo "Error: No se pudo obtener el ARN del rol de ejecución de ECS"
            exit 1
          fi
          
          # Registrar la definición de la tarea ECS
          aws ecs register-task-definition \
            --family ${{ env.ECS_CLUSTER }}-task \
            --execution-role-arn "$TASK_EXECUTION_ROLE_ARN" \
            --network-mode awsvpc \
            --requires-compatibilities FARGATE \
            --cpu 256 \
            --memory 512 \
            --container-definitions '[
              {
                "name": "${{ env.CONTAINER_NAME }}",
                "image": "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ github.sha }}",
                "portMappings": [
                  {
                    "containerPort": 80,
                    "hostPort": 80,
                    "protocol": "tcp"
                  }
                ],
                "environment": [
                  {
                    "name": "REACT_APP_API_URL",
                    "value": "'${API_GATEWAY_URL}'"
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/${{ env.ECS_CLUSTER }}",
                    "awslogs-region": "${{ env.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ]'
          
          # Actualizar el servicio ECS
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.ECS_CLUSTER }}-task \
            --force-new-deployment

